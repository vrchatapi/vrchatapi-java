/*
 * VRChat API Documentation
 *
 * The version of the OpenAPI document: 1.17.6
 * Contact: vrchatapi.lpv0t@aries.fyi
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.vrchatapi.api;

import io.github.vrchatapi.ApiCallback;
import io.github.vrchatapi.ApiClient;
import io.github.vrchatapi.ApiException;
import io.github.vrchatapi.ApiResponse;
import io.github.vrchatapi.Configuration;
import io.github.vrchatapi.Pair;
import io.github.vrchatapi.ProgressRequestBody;
import io.github.vrchatapi.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.github.vrchatapi.model.CurrentUser;
import io.github.vrchatapi.model.Error;
import io.github.vrchatapi.model.Success;
import io.github.vrchatapi.model.TwoFactorAuthCode;
import io.github.vrchatapi.model.TwoFactorEmailCode;
import io.github.vrchatapi.model.UserExists;
import io.github.vrchatapi.model.Verify2FAEmailCodeResult;
import io.github.vrchatapi.model.Verify2FAResult;
import io.github.vrchatapi.model.VerifyAuthTokenResult;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class AuthenticationApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AuthenticationApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AuthenticationApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for checkUserExists
     * @param email Filter by email. (optional)
     * @param displayName Filter by displayName. (optional)
     * @param userId Filter by UserID. (optional)
     * @param excludeUserId Exclude by UserID. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a response if a user exists or not. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error response when missing at least 1 of the required parameters. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call checkUserExistsCall(String email, String displayName, String userId, String excludeUserId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/auth/exists";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (email != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("email", email));
        }

        if (displayName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("displayName", displayName));
        }

        if (userId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("userId", userId));
        }

        if (excludeUserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("excludeUserId", excludeUserId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call checkUserExistsValidateBeforeCall(String email, String displayName, String userId, String excludeUserId, final ApiCallback _callback) throws ApiException {
        return checkUserExistsCall(email, displayName, userId, excludeUserId, _callback);

    }

    /**
     * Check User Exists
     * Checks if a user by a given &#x60;username&#x60;, &#x60;displayName&#x60; or &#x60;email&#x60; exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the &#x60;excludeUserId&#x60; is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** &#x60;username&#x60;, &#x60;displayName&#x60; **or** &#x60;email&#x60; query parameter. Although they can be combined - in addition with &#x60;excludeUserId&#x60; (generally to exclude yourself) - to further fine-tune the search.
     * @param email Filter by email. (optional)
     * @param displayName Filter by displayName. (optional)
     * @param userId Filter by UserID. (optional)
     * @param excludeUserId Exclude by UserID. (optional)
     * @return UserExists
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a response if a user exists or not. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error response when missing at least 1 of the required parameters. </td><td>  -  </td></tr>
     </table>
     */
    public UserExists checkUserExists(String email, String displayName, String userId, String excludeUserId) throws ApiException {
        ApiResponse<UserExists> localVarResp = checkUserExistsWithHttpInfo(email, displayName, userId, excludeUserId);
        return localVarResp.getData();
    }

    /**
     * Check User Exists
     * Checks if a user by a given &#x60;username&#x60;, &#x60;displayName&#x60; or &#x60;email&#x60; exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the &#x60;excludeUserId&#x60; is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** &#x60;username&#x60;, &#x60;displayName&#x60; **or** &#x60;email&#x60; query parameter. Although they can be combined - in addition with &#x60;excludeUserId&#x60; (generally to exclude yourself) - to further fine-tune the search.
     * @param email Filter by email. (optional)
     * @param displayName Filter by displayName. (optional)
     * @param userId Filter by UserID. (optional)
     * @param excludeUserId Exclude by UserID. (optional)
     * @return ApiResponse&lt;UserExists&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a response if a user exists or not. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error response when missing at least 1 of the required parameters. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<UserExists> checkUserExistsWithHttpInfo(String email, String displayName, String userId, String excludeUserId) throws ApiException {
        okhttp3.Call localVarCall = checkUserExistsValidateBeforeCall(email, displayName, userId, excludeUserId, null);
        Type localVarReturnType = new TypeToken<UserExists>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Check User Exists (asynchronously)
     * Checks if a user by a given &#x60;username&#x60;, &#x60;displayName&#x60; or &#x60;email&#x60; exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the &#x60;excludeUserId&#x60; is used to exclude oneself, otherwise the result would always be true.  It is **REQUIRED** to include **AT LEAST** &#x60;username&#x60;, &#x60;displayName&#x60; **or** &#x60;email&#x60; query parameter. Although they can be combined - in addition with &#x60;excludeUserId&#x60; (generally to exclude yourself) - to further fine-tune the search.
     * @param email Filter by email. (optional)
     * @param displayName Filter by displayName. (optional)
     * @param userId Filter by UserID. (optional)
     * @param excludeUserId Exclude by UserID. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns a response if a user exists or not. </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Error response when missing at least 1 of the required parameters. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call checkUserExistsAsync(String email, String displayName, String userId, String excludeUserId, final ApiCallback<UserExists> _callback) throws ApiException {

        okhttp3.Call localVarCall = checkUserExistsValidateBeforeCall(email, displayName, userId, excludeUserId, _callback);
        Type localVarReturnType = new TypeToken<UserExists>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteUser
     * @param userId Must be a valid user ID. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteUserCall(String userId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{userId}/delete"
            .replace("{" + "userId" + "}", localVarApiClient.escapeString(userId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "authCookie" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteUserValidateBeforeCall(String userId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userId' is set
        if (userId == null) {
            throw new ApiException("Missing the required parameter 'userId' when calling deleteUser(Async)");
        }

        return deleteUserCall(userId, _callback);

    }

    /**
     * Delete User
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     * @param userId Must be a valid user ID. (required)
     * @return CurrentUser
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public CurrentUser deleteUser(String userId) throws ApiException {
        ApiResponse<CurrentUser> localVarResp = deleteUserWithHttpInfo(userId);
        return localVarResp.getData();
    }

    /**
     * Delete User
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     * @param userId Must be a valid user ID. (required)
     * @return ApiResponse&lt;CurrentUser&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CurrentUser> deleteUserWithHttpInfo(String userId) throws ApiException {
        okhttp3.Call localVarCall = deleteUserValidateBeforeCall(userId, null);
        Type localVarReturnType = new TypeToken<CurrentUser>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete User (asynchronously)
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.  **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.  **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     * @param userId Must be a valid user ID. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteUserAsync(String userId, final ApiCallback<CurrentUser> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteUserValidateBeforeCall(userId, _callback);
        Type localVarReturnType = new TypeToken<CurrentUser>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCurrentUser
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Successful authentication returns an &#x60;auth&#x60; cookie. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCurrentUserCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/auth/user";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "authCookie", "authHeader", "twoFactorAuthCookie" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCurrentUserValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return getCurrentUserCall(_callback);

    }

    /**
     * Login and/or Get Current User Info
     * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid &#x60;auth&#x60; cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the &#x60;Authorization&#x60; header and set the &#x60;auth&#x60; cookie. The &#x60;auth&#x60; cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after &#x60;Authorization: Basic {string}&#x60; is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    &gt; base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the &#x60;auth&#x60; cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     * @return CurrentUser
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Successful authentication returns an &#x60;auth&#x60; cookie. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public CurrentUser getCurrentUser() throws ApiException {
        ApiResponse<CurrentUser> localVarResp = getCurrentUserWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Login and/or Get Current User Info
     * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid &#x60;auth&#x60; cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the &#x60;Authorization&#x60; header and set the &#x60;auth&#x60; cookie. The &#x60;auth&#x60; cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after &#x60;Authorization: Basic {string}&#x60; is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    &gt; base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the &#x60;auth&#x60; cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     * @return ApiResponse&lt;CurrentUser&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Successful authentication returns an &#x60;auth&#x60; cookie. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CurrentUser> getCurrentUserWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getCurrentUserValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<CurrentUser>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Login and/or Get Current User Info (asynchronously)
     * This endpoint does the following two operations:   1) Checks if you are already logged in by looking for a valid &#x60;auth&#x60; cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the &#x60;Authorization&#x60; header and set the &#x60;auth&#x60; cookie. The &#x60;auth&#x60; cookie will only be sent once.   2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.  The auth string after &#x60;Authorization: Basic {string}&#x60; is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.    &gt; base64(urlencode(username):urlencode(password))  **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the &#x60;auth&#x60; cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Successful authentication returns an &#x60;auth&#x60; cookie. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCurrentUserAsync(final ApiCallback<CurrentUser> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCurrentUserValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<CurrentUser>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for logout
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Clears the &#x60;auth&#x60; cookie. <br>  * \0Set-Cookie - Clears the &#x60;age&#x60; cookie. <br>  * \0\0Set-Cookie - Clears the &#x60;tos&#x60; cookie. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call logoutCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/logout";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "authCookie" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call logoutValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return logoutCall(_callback);

    }

    /**
     * Logout
     * Invalidates the login session.
     * @return Success
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Clears the &#x60;auth&#x60; cookie. <br>  * \0Set-Cookie - Clears the &#x60;age&#x60; cookie. <br>  * \0\0Set-Cookie - Clears the &#x60;tos&#x60; cookie. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public Success logout() throws ApiException {
        ApiResponse<Success> localVarResp = logoutWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Logout
     * Invalidates the login session.
     * @return ApiResponse&lt;Success&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Clears the &#x60;auth&#x60; cookie. <br>  * \0Set-Cookie - Clears the &#x60;age&#x60; cookie. <br>  * \0\0Set-Cookie - Clears the &#x60;tos&#x60; cookie. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Success> logoutWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = logoutValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<Success>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Logout (asynchronously)
     * Invalidates the login session.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Clears the &#x60;auth&#x60; cookie. <br>  * \0Set-Cookie - Clears the &#x60;age&#x60; cookie. <br>  * \0\0Set-Cookie - Clears the &#x60;tos&#x60; cookie. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call logoutAsync(final ApiCallback<Success> _callback) throws ApiException {

        okhttp3.Call localVarCall = logoutValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<Success>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for verify2FA
     * @param twoFactorAuthCode  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call verify2FACall(TwoFactorAuthCode twoFactorAuthCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = twoFactorAuthCode;

        // create path and map variables
        String localVarPath = "/auth/twofactorauth/totp/verify";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "authCookie" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call verify2FAValidateBeforeCall(TwoFactorAuthCode twoFactorAuthCode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'twoFactorAuthCode' is set
        if (twoFactorAuthCode == null) {
            throw new ApiException("Missing the required parameter 'twoFactorAuthCode' when calling verify2FA(Async)");
        }

        return verify2FACall(twoFactorAuthCode, _callback);

    }

    /**
     * Verify 2FA code
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     * @param twoFactorAuthCode  (required)
     * @return Verify2FAResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public Verify2FAResult verify2FA(TwoFactorAuthCode twoFactorAuthCode) throws ApiException {
        ApiResponse<Verify2FAResult> localVarResp = verify2FAWithHttpInfo(twoFactorAuthCode);
        return localVarResp.getData();
    }

    /**
     * Verify 2FA code
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     * @param twoFactorAuthCode  (required)
     * @return ApiResponse&lt;Verify2FAResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Verify2FAResult> verify2FAWithHttpInfo(TwoFactorAuthCode twoFactorAuthCode) throws ApiException {
        okhttp3.Call localVarCall = verify2FAValidateBeforeCall(twoFactorAuthCode, null);
        Type localVarReturnType = new TypeToken<Verify2FAResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Verify 2FA code (asynchronously)
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     * @param twoFactorAuthCode  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call verify2FAAsync(TwoFactorAuthCode twoFactorAuthCode, final ApiCallback<Verify2FAResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = verify2FAValidateBeforeCall(twoFactorAuthCode, _callback);
        Type localVarReturnType = new TypeToken<Verify2FAResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for verify2FAEmailCode
     * @param twoFactorEmailCode  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call verify2FAEmailCodeCall(TwoFactorEmailCode twoFactorEmailCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = twoFactorEmailCode;

        // create path and map variables
        String localVarPath = "/auth/twofactorauth/emailotp/verify";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "authCookie" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call verify2FAEmailCodeValidateBeforeCall(TwoFactorEmailCode twoFactorEmailCode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'twoFactorEmailCode' is set
        if (twoFactorEmailCode == null) {
            throw new ApiException("Missing the required parameter 'twoFactorEmailCode' when calling verify2FAEmailCode(Async)");
        }

        return verify2FAEmailCodeCall(twoFactorEmailCode, _callback);

    }

    /**
     * Verify 2FA email code
     * Finishes the login sequence with an 2FA email code.
     * @param twoFactorEmailCode  (required)
     * @return Verify2FAEmailCodeResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public Verify2FAEmailCodeResult verify2FAEmailCode(TwoFactorEmailCode twoFactorEmailCode) throws ApiException {
        ApiResponse<Verify2FAEmailCodeResult> localVarResp = verify2FAEmailCodeWithHttpInfo(twoFactorEmailCode);
        return localVarResp.getData();
    }

    /**
     * Verify 2FA email code
     * Finishes the login sequence with an 2FA email code.
     * @param twoFactorEmailCode  (required)
     * @return ApiResponse&lt;Verify2FAEmailCodeResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Verify2FAEmailCodeResult> verify2FAEmailCodeWithHttpInfo(TwoFactorEmailCode twoFactorEmailCode) throws ApiException {
        okhttp3.Call localVarCall = verify2FAEmailCodeValidateBeforeCall(twoFactorEmailCode, null);
        Type localVarReturnType = new TypeToken<Verify2FAEmailCodeResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Verify 2FA email code (asynchronously)
     * Finishes the login sequence with an 2FA email code.
     * @param twoFactorEmailCode  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call verify2FAEmailCodeAsync(TwoFactorEmailCode twoFactorEmailCode, final ApiCallback<Verify2FAEmailCodeResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = verify2FAEmailCodeValidateBeforeCall(twoFactorEmailCode, _callback);
        Type localVarReturnType = new TypeToken<Verify2FAEmailCodeResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for verifyAuthToken
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns wether a provided auth token is valid or not. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call verifyAuthTokenCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/auth";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "authCookie" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call verifyAuthTokenValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return verifyAuthTokenCall(_callback);

    }

    /**
     * Verify Auth Token
     * Verify whether the currently provided Auth Token is valid.
     * @return VerifyAuthTokenResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns wether a provided auth token is valid or not. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public VerifyAuthTokenResult verifyAuthToken() throws ApiException {
        ApiResponse<VerifyAuthTokenResult> localVarResp = verifyAuthTokenWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Verify Auth Token
     * Verify whether the currently provided Auth Token is valid.
     * @return ApiResponse&lt;VerifyAuthTokenResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns wether a provided auth token is valid or not. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<VerifyAuthTokenResult> verifyAuthTokenWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = verifyAuthTokenValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<VerifyAuthTokenResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Verify Auth Token (asynchronously)
     * Verify whether the currently provided Auth Token is valid.
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Returns wether a provided auth token is valid or not. </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call verifyAuthTokenAsync(final ApiCallback<VerifyAuthTokenResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = verifyAuthTokenValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<VerifyAuthTokenResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for verifyRecoveryCode
     * @param twoFactorAuthCode  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call verifyRecoveryCodeCall(TwoFactorAuthCode twoFactorAuthCode, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = twoFactorAuthCode;

        // create path and map variables
        String localVarPath = "/auth/twofactorauth/otp/verify";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "authCookie" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call verifyRecoveryCodeValidateBeforeCall(TwoFactorAuthCode twoFactorAuthCode, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'twoFactorAuthCode' is set
        if (twoFactorAuthCode == null) {
            throw new ApiException("Missing the required parameter 'twoFactorAuthCode' when calling verifyRecoveryCode(Async)");
        }

        return verifyRecoveryCodeCall(twoFactorAuthCode, _callback);

    }

    /**
     * Verify 2FA code with Recovery code
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     * @param twoFactorAuthCode  (required)
     * @return Verify2FAResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public Verify2FAResult verifyRecoveryCode(TwoFactorAuthCode twoFactorAuthCode) throws ApiException {
        ApiResponse<Verify2FAResult> localVarResp = verifyRecoveryCodeWithHttpInfo(twoFactorAuthCode);
        return localVarResp.getData();
    }

    /**
     * Verify 2FA code with Recovery code
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     * @param twoFactorAuthCode  (required)
     * @return ApiResponse&lt;Verify2FAResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Verify2FAResult> verifyRecoveryCodeWithHttpInfo(TwoFactorAuthCode twoFactorAuthCode) throws ApiException {
        okhttp3.Call localVarCall = verifyRecoveryCodeValidateBeforeCall(twoFactorAuthCode, null);
        Type localVarReturnType = new TypeToken<Verify2FAResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Verify 2FA code with Recovery code (asynchronously)
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     * @param twoFactorAuthCode  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  * Set-Cookie - Provides a &#x60;twoFactorAuth&#x60; cookie, which can be used to bypasses the 2FA requirement for future logins on the same device. <br>  </td></tr>
        <tr><td> 401 </td><td> Error response due to missing auth cookie. </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call verifyRecoveryCodeAsync(TwoFactorAuthCode twoFactorAuthCode, final ApiCallback<Verify2FAResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = verifyRecoveryCodeValidateBeforeCall(twoFactorAuthCode, _callback);
        Type localVarReturnType = new TypeToken<Verify2FAResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
